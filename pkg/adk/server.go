package adk

import (
	"fmt"
	"io"
	"log"
	"net"

	mesh "github.com/ThisaraWeerakoon/Agent-Mesh/pkg/api/v1/mesh"
	"google.golang.org/adk/agent"
	"google.golang.org/adk/runner"
	"google.golang.org/adk/session"
	"google.golang.org/genai"
	"google.golang.org/grpc"
)

// ServerWrapper acts as the bridge between AgentMesh sidecar and the standard ADK Agent.
// It implements the A2AMeshService interface.
type ServerWrapper struct {
	mesh.UnimplementedA2AMeshServiceServer
	agent agent.Agent
}

// ServeAgent starts a gRPC server that listens for AgentMesh tasks and forwards them to the provided ADK agent.
// This blocks until the server stops.
func ServeAgent(port int, agent agent.Agent) error {
	lis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", port))
	if err != nil {
		return fmt.Errorf("failed to listen on port %d: %w", port, err)
	}

	s := grpc.NewServer()
	mesh.RegisterA2AMeshServiceServer(s, &ServerWrapper{agent: agent})

	log.Printf("Agent server listening on localhost:%d", port)
	return s.Serve(lis)
}

// StreamTask handles incoming task streams from the Sidecar.
func (s *ServerWrapper) StreamTask(stream mesh.A2AMeshService_StreamTaskServer) error {
	ctx := stream.Context()
	log.Println("New incoming task stream")

	for {
		event, err := stream.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			return err
		}

		switch e := event.Event.(type) {
		case *mesh.StreamEvent_TaskStart:
			log.Printf("Received TaskStart: %v", e.TaskStart)

			if msg := e.TaskStart.Request.Message; msg != nil {
				// 1. Setup Runner and Session
				// We use an in-memory session for simplicity of this example.
				// In a real scenario, you might want persistent storage.
				// Each TaskStart is treated as a new session here or we could wire up SessionID.
				sessionService := session.InMemoryService()

				r, err := runner.New(runner.Config{
					AppName:        s.agent.Name(),
					Agent:          s.agent,
					SessionService: sessionService,
				})
				if err != nil {
					return fmt.Errorf("failed to create runner: %w", err)
				}

				// 2. Extract Input as genai.Content
				var prompt string
				for _, part := range msg.Parts {
					if txt, ok := part.Content.(*mesh.Part_TextPart); ok {
						prompt += txt.TextPart + "\n"
					}
					// Handle DataPart (Function Call arguments) if needed.
					// If the remote tool passed structured data, it might be in DataPart.
					if data, ok := part.Content.(*mesh.Part_DataPart); ok {
						// Simplistic handling: convert to string representation or map it.
						// For now, assuming text-based agents or relying on text serialization.
						if textVal, ok := data.DataPart.Fields["text"]; ok {
							prompt += textVal.GetStringValue() + "\n"
						}
					}
				}

				// 3. Run Agent
				inputContent := &genai.Content{
					Parts: []*genai.Part{
						genai.NewPartFromText(prompt),
					},
					Role: "user",
				}

				// Using Task ContextId as SessionID if provided, else generated by runner if left empty?
				// Runner.Run needs sessionID.
				sessionID := e.TaskStart.Request.ContextId
				if sessionID == "" {
					sessionID = "default-session"
				}

				// Create Session explicitly
				_, err = sessionService.Create(ctx, &session.CreateRequest{
					AppName:   s.agent.Name(),
					UserID:    "user",
					SessionID: sessionID,
				})
				if err != nil {
					return fmt.Errorf("failed to create session: %w", err)
				}

				log.Printf("Running agent with input: %s", prompt)

				// Iterate over events from the runner
				for evt, err := range r.Run(ctx, "user", sessionID, inputContent, agent.RunConfig{}) {
					if err != nil {
						log.Printf("Runner error: %v", err)
						// Send error status?
						return err
					}

					// 4. Stream Response
					// Convert ADK Session Event to Mesh StreamEvent
					// We are primarily interested in the final response (Model Response)
					// or tool calls if we wanted to proxy them back (advanced).
					// For now, let's stream the text content generated by the model.

					if evt.LLMResponse.Content != nil {
						for _, part := range evt.LLMResponse.Content.Parts {
							if part.Text != "" {
								// Send status update with partial text?
								// Or wait for final. Let's send accumulated text or chunks.
								// The 'evt' corresponds to a step.
								resp := &mesh.StreamEvent{
									Event: &mesh.StreamEvent_StatusUpdate{
										StatusUpdate: &mesh.TaskStatusUpdate{
											TaskId:  e.TaskStart.Request.ContextId,
											Status:  mesh.Task_WORKING, // Or completed if final
											Message: part.Text,
										},
									},
								}
								if err := stream.Send(resp); err != nil {
									return err
								}
							}
						}
					}

					// Detect completion using IsFinalResponse (helper not available, check properties)
					// Or just when loop finishes.
				}

				// Send Completion
				resp := &mesh.StreamEvent{
					Event: &mesh.StreamEvent_StatusUpdate{
						StatusUpdate: &mesh.TaskStatusUpdate{
							TaskId: e.TaskStart.Request.ContextId,
							Status: mesh.Task_COMPLETED,
						},
					},
				}
				if err := stream.Send(resp); err != nil {
					return err
				}
			}

		case *mesh.StreamEvent_StatusUpdate:
			log.Printf("Received StatusUpdate: %v", e.StatusUpdate)
		case *mesh.StreamEvent_ArtifactUpdate:
			log.Printf("Received ArtifactUpdate: %v", e.ArtifactUpdate)
		}
	}
}
